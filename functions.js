module.exports.require = function require(path) {
    return self.require(path);
  }
module.exports.fs = {"Stats":"function (\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n  this.atime = new Date(atim_msec);\n  this.mtime = new Date(mtim_msec);\n  this.ctime = new Date(ctim_msec);\n  this.birthtime = new Date(birthtim_msec);\n}","F_OK":0,"R_OK":4,"W_OK":2,"X_OK":1,"access":"function (path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = fs.F_OK;\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('callback must be a function');\n  }\n\n  if (!nullCheck(path, callback))\n    return;\n\n  mode = mode | 0;\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.access(pathModule._makeLong(path), mode, req);\n}","accessSync":"function (path, mode) {\n  nullCheck(path);\n\n  if (mode === undefined)\n    mode = fs.F_OK;\n  else\n    mode = mode | 0;\n\n  binding.access(pathModule._makeLong(path), mode);\n}","exists":"function (path, callback) {\n  if (!nullCheck(path, cb)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = cb;\n  binding.stat(pathModule._makeLong(path), req);\n  function cb(err, stats) {\n    if (callback) callback(err ? false : true);\n  }\n}","existsSync":"function (path) {\n  try {\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","readFile":"function (path, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (!options || typeof options === 'function') {\n    options = { encoding: null, flag: 'r' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, flag: 'r' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  var flag = options.flag || 'r';\n\n  if (!nullCheck(path, callback))\n    return;\n\n  var context = new ReadFileContext(callback, encoding);\n  var req = new FSReqWrap();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flag),\n               0o666,\n               req);\n}","readFileSync":"function (path, options) {\n  if (!options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, flag: 'r' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  var flag = options.flag || 'r';\n  var fd = fs.openSync(path, flag, 0o666);\n\n  var st;\n  var size;\n  var threw = true;\n  try {\n    st = fs.fstatSync(fd);\n    size = st.isFile() ? st.size : 0;\n    threw = false;\n  } finally {\n    if (threw) fs.closeSync(fd);\n  }\n\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    threw = true;\n    try {\n      buffer = new Buffer(size);\n      threw = false;\n    } finally {\n      if (threw) fs.closeSync(fd);\n    }\n  }\n\n  var done = false;\n  var bytesRead;\n\n  while (!done) {\n    threw = true;\n    try {\n      if (size !== 0) {\n        bytesRead = fs.readSync(fd, buffer, pos, size - pos);\n      } else {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffer = new Buffer(8192);\n        bytesRead = fs.readSync(fd, buffer, 0, 8192);\n        if (bytesRead) {\n          buffers.push(buffer.slice(0, bytesRead));\n        }\n      }\n      threw = false;\n    } finally {\n      if (threw) fs.closeSync(fd);\n    }\n\n    pos += bytesRead;\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\n  }\n\n  fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (encoding) buffer = buffer.toString(encoding);\n  return buffer;\n}","close":"function (fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.close(fd, req);\n}","closeSync":"function (fd) {\n  return binding.close(fd);\n}","open":"function (path, flags, mode, callback_) {\n  var callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 0o666);\n\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               req);\n}","openSync":"function (path, flags, mode) {\n  mode = modeNum(mode, 0o666);\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n}","read":"function (fd, buffer, offset, length, position, callback) {\n  if (!(buffer instanceof Buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    const cb = arguments[4];\n    const encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n    offset = 0;\n\n    callback = function(err, bytesRead) {\n      if (!cb) return;\n\n      var str = (bytesRead > 0) ? buffer.toString(encoding, 0, bytesRead) : '';\n\n      (cb)(err, str, bytesRead);\n    };\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  binding.read(fd, buffer, offset, length, position, req);\n}","readSync":"function (fd, buffer, offset, length, position) {\n  var legacy = false;\n  var encoding;\n\n  if (!(buffer instanceof Buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    legacy = true;\n    encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n\n    offset = 0;\n  }\n\n  var r = binding.read(fd, buffer, offset, length, position);\n  if (!legacy) {\n    return r;\n  }\n\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\n  return [str, r];\n}","write":"function (fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  if (buffer instanceof Buffer) {\n    // if no position is passed then assume null\n    if (typeof position === 'function') {\n      callback = position;\n      position = null;\n    }\n    callback = maybeCallback(callback);\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n  return binding.writeString(fd, buffer, offset, length, req);\n}","writeSync":"function (fd, buffer, offset, length, position) {\n  if (buffer instanceof Buffer) {\n    if (position === undefined)\n      position = null;\n    return binding.writeBuffer(fd, buffer, offset, length, position);\n  }\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (offset === undefined)\n    offset = null;\n  return binding.writeString(fd, buffer, offset, length, position);\n}","rename":"function (oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 req);\n}","renameSync":"function (oldPath, newPath) {\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n}","truncate":"function (path, len, callback) {\n  if (typeof path === 'number') {\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    var req = new FSReqWrap();\n    req.oncomplete = function ftruncateCb(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n}","truncateSync":"function (path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  var ret;\n\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}","ftruncate":"function (fd, len, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.ftruncate(fd, len, req);\n}","ftruncateSync":"function (fd, len) {\n  if (len === undefined) {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n}","rmdir":"function (path, callback) {\n  callback = maybeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rmdir(pathModule._makeLong(path), req);\n}","rmdirSync":"function (path) {\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n}","fdatasync":"function (fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n}","fdatasyncSync":"function (fd) {\n  return binding.fdatasync(fd);\n}","fsync":"function (fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n}","fsyncSync":"function (fd) {\n  return binding.fsync(fd);\n}","mkdir":"function (path, mode, callback) {\n  if (typeof mode === 'function') callback = mode;\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 0o777),\n                req);\n}","mkdirSync":"function (path, mode) {\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 0o777));\n}","readdir":"function (path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readdir(pathModule._makeLong(path), req);\n}","readdirSync":"function (path) {\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path));\n}","fstat":"function (fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fstat(fd, req);\n}","lstat":"function (path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.lstat(pathModule._makeLong(path), req);\n}","stat":"function (path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.stat(pathModule._makeLong(path), req);\n}","fstatSync":"function (fd) {\n  return binding.fstat(fd);\n}","lstatSync":"function (path) {\n  nullCheck(path);\n  return binding.lstat(pathModule._makeLong(path));\n}","statSync":"function (path) {\n  nullCheck(path);\n  return binding.stat(pathModule._makeLong(path));\n}","readlink":"function (path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readlink(pathModule._makeLong(path), req);\n}","readlinkSync":"function (path) {\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path));\n}","symlink":"function (target, path, type_, callback_) {\n  var type = (typeof type_ === 'string' ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (!nullCheck(target, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\n                  pathModule._makeLong(path),\n                  type,\n                  req);\n}","symlinkSync":"function (target, path, type) {\n  type = (typeof type === 'string' ? type : null);\n\n  nullCheck(target);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n                         pathModule._makeLong(path),\n                         type);\n}","link":"function (srcpath, dstpath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(srcpath, callback)) return;\n  if (!nullCheck(dstpath, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.link(pathModule._makeLong(srcpath),\n               pathModule._makeLong(dstpath),\n               req);\n}","linkSync":"function (srcpath, dstpath) {\n  nullCheck(srcpath);\n  nullCheck(dstpath);\n  return binding.link(pathModule._makeLong(srcpath),\n                      pathModule._makeLong(dstpath));\n}","unlink":"function (path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.unlink(pathModule._makeLong(path), req);\n}","unlinkSync":"function (path) {\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n}","fchmod":"function (fd, mode, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchmod(fd, modeNum(mode), req);\n}","fchmodSync":"function (fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n}","chmod":"function (path, mode, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                req);\n}","chmodSync":"function (path, mode) {\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n}","fchown":"function (fd, uid, gid, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchown(fd, uid, gid, req);\n}","fchownSync":"function (fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n}","chown":"function (path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\n}","chownSync":"function (path, uid, gid) {\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n}","_toUnixTimestamp":"function toUnixTimestamp(time) {\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (typeof time === 'number') {\n    if (!Number.isFinite(time) || time < 0) {\n      return Date.now() / 1000;\n    }\n    return time;\n  }\n  if (util.isDate(time)) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}","utimes":"function (path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 req);\n}","utimesSync":"function (path, atime, mtime) {\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n}","futimes":"function (fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.futimes(fd, atime, mtime, req);\n}","futimesSync":"function (fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n}","writeFile":"function (path, data, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (!options || typeof options === 'function') {\n    options = { encoding: 'utf8', mode: 0o666, flag: 'w' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 0o666, flag: 'w' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      var buffer = (data instanceof Buffer) ? data : new Buffer('' + data,\n          options.encoding || 'utf8');\n      var position = /a/.test(flag) ? null : 0;\n      writeAll(fd, buffer, 0, buffer.length, position, callback);\n    }\n  });\n}","writeFileSync":"function (path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 0o666, flag: 'w' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 0o666, flag: 'w' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  var fd = fs.openSync(path, flag, options.mode);\n  if (!(data instanceof Buffer)) {\n    data = new Buffer('' + data, options.encoding || 'utf8');\n  }\n  var offset = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (length > 0) {\n      var written = fs.writeSync(fd, data, offset, length, position);\n      offset += written;\n      length -= written;\n      if (position !== null) {\n        position += written;\n      }\n    }\n  } finally {\n    fs.closeSync(fd);\n  }\n}","appendFile":"function (path, data, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (!options || typeof options === 'function') {\n    options = { encoding: 'utf8', mode: 0o666, flag: 'a' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 0o666, flag: 'a' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  fs.writeFile(path, data, options, callback);\n}","appendFileSync":"function (path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 0o666, flag: 'a' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 0o666, flag: 'a' };\n  } else if (typeof options !== 'object') {\n    throwOptionsError(options);\n  }\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n\n  fs.writeFileSync(path, data, options);\n}","watch":"function (filename) {\n  nullCheck(filename);\n  var watcher;\n  var options;\n  var listener;\n\n  if (arguments[1] !== null && typeof arguments[1] === 'object') {\n    options = arguments[1];\n    listener = arguments[2];\n  } else {\n    options = {};\n    listener = arguments[1];\n  }\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n\n  watcher = new FSWatcher();\n  watcher.start(filename, options.persistent, options.recursive);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n}","watchFile":"function (filename, options, listener) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n\n  var defaults = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if (options !== null && typeof options === 'object') {\n    options = util._extend(defaults, options);\n  } else {\n    listener = options;\n    options = defaults;\n  }\n\n  if (typeof listener !== 'function') {\n    throw new Error('watchFile requires a listener function');\n  }\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n    statWatchers.set(filename, stat);\n  }\n\n  stat.addListener('change', listener);\n  return stat;\n}","unwatchFile":"function (filename, listener) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}","realpathSync":"function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  const original = p;\n  const seenLinks = {};\n  const knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n}","realpath":"function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  const original = p;\n  const seenLinks = {};\n  const knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n}","createReadStream":"function (path, options) {\n  return new ReadStream(path, options);\n}","ReadStream":"function ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('options must be a string or an object');\n\n  // a little bit bigger buffer and water marks by default\n  options = Object.create(options);\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  Readable.call(this, options);\n\n  this.path = path;\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = undefined;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('start must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if (typeof this.end !== 'number') {\n      throw new TypeError('end must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('start must be <= end');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}","FileReadStream":"function ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('options must be a string or an object');\n\n  // a little bit bigger buffer and water marks by default\n  options = Object.create(options);\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  Readable.call(this, options);\n\n  this.path = path;\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = undefined;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('start must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if (typeof this.end !== 'number') {\n      throw new TypeError('end must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('start must be <= end');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}","createWriteStream":"function (path, options) {\n  return new WriteStream(path, options);\n}","WriteStream":"function WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('options must be a string or an object');\n\n  options = Object.create(options);\n\n  Writable.call(this, options);\n\n  this.path = path;\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('start must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('start must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', this.close);\n}","FileWriteStream":"function WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('options must be a string or an object');\n\n  options = Object.create(options);\n\n  Writable.call(this, options);\n\n  this.path = path;\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('start must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('start must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', this.close);\n}"}
module.exports.console = {"log":"function () { [native code] }","info":"function () { [native code] }","warn":"function () { [native code] }","error":"function () { [native code] }","dir":"function () { [native code] }","time":"function () { [native code] }","timeEnd":"function () { [native code] }","trace":"function () { [native code] }","assert":"function () { [native code] }","Console":"function Console(stdout, stderr) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr);\n  }\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  } else if (typeof stderr.write !== 'function') {\n    throw new TypeError('Console expects writable stream instances');\n  }\n\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = new Map();\n  Object.defineProperty(this, '_times', prop);\n\n  // bind the prototype functions to this Console instance\n  var keys = Object.keys(Console.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var k = keys[v];\n    this[k] = this[k].bind(this);\n  }\n}"}
module.exports.x = 4
module.exports.output = "55555"
module.exports.y = "3"
module.exports.options = {"deps":["fs","console"],"prompt":{"color":[91,39],"txt":" >> "},"types":{"string":[32,39],"number":[33,39],"function":[36,39],"boolean":[35,39],"undefined":[35,39],"error":[31,39]},"custom":{"{":[43,49],"}":[43,49]},"str":"'"}
module.exports.z = "55555"
module.exports.r = 4
module.exports.red = "red"
